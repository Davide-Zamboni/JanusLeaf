# KMP Architecture Deep Dive (App Module)

This document explains how the KMP app module is structured and how data flows through it.
It is intentionally focused on implementation details and iOS integration.
For high-level architecture, tech stack, and run instructions, see `app/README.md`.

## Scope

This doc covers:
- Architectural patterns inside the `app/` KMP project.
- How data flows from UI to shared code and back.
- Where data is stored and cached.
- How the shared Kotlin code is adapted for iOS (SwiftUI).

This doc does not repeat build/setup steps or the tech stack.

## Module Map

- `app/shared`
  - Shared KMP module with domain models, repositories, networking, stores, and KMP view models.
  - Exposes a Kotlin/Native framework named `Shared` for iOS.
- `app/composeApp`
  - Android-only UI (Jetpack Compose).
  - Wires Koin DI modules and hosts the navigation flow.
- `app/iosApp`
  - iOS-only UI (SwiftUI).
  - Uses Swift adapters to bridge Kotlin Flows and types into SwiftUI.

## End-to-End Data Flow (Example: Journal List)

This is the most common flow pattern. Other features follow the same shape.

1. UI triggers an action.
   - Android: Compose screen calls a shared ViewModel method.
   - iOS: SwiftUI view calls an adapter method which delegates to the shared ViewModel.
2. Shared ViewModel delegates to a Store.
   - Example: `JournalListViewModel.loadEntries()` calls `JournalStore.loadEntries()`.
3. Store calls a Repository interface.
   - Example: `JournalStore` calls `JournalRepository.listEntries()`.
4. Repository implementation makes a network request.
   - Uses Ktor `HttpClient` and `JournalApiService`.
   - Adds auth tokens from `TokenStorage` when required.
5. DTOs are parsed and mapped to domain models.
   - DTOs live in `data/remote/dto` and expose `toDomain()` mapping functions.
6. Store updates in-memory caches.
   - `JournalCache` is updated with fresh entries.
7. Cache updates flow to the UI.
   - Stores expose `Flow` or `StateFlow` that ViewModels collect.
   - ViewModels expose UI state objects (`JournalListUiState`, etc.).
8. UI re-renders with the updated state.
   - Android: `collectAsStateWithLifecycle()` on `StateFlow`.
   - iOS: `FlowObserver` updates `@Published` properties on adapters.

## Shared Module Architecture

The shared module follows a Clean Architecture style, with a thin presentation layer on top.
The important part is that UI code never talks directly to networking or storage.

### Domain Layer

- Pure data classes like `Journal`, `User`, `AuthTokens`.
- Result types (`AuthResult`, `JournalResult`) wrap success/error outcomes.
- Repository interfaces (for example `AuthRepository`, `JournalRepository`).

These types are shared by both Android and iOS.

### Data Layer

- API services (`AuthApiService`, `JournalApiService`, `InspirationApiService`).
- DTOs that map to domain models (`toDomain()` functions).
- Repository implementations (`AuthRepositoryImpl`, `JournalRepositoryImpl`).
- Platform-specific implementations for storage and networking.

Repository implementations are responsible for:
- Fetching/storing tokens.
- Automatic token refresh on 401/Unauthorized responses.
- Mapping DTOs to domain models.

### State/Store Layer

Stores are a shared state manager that own the in-memory caches and UI-facing flows.
They are long-lived and reused across ViewModels.

- `AuthStore` exposes `StateFlow<AuthUiState>` and listens to token changes.
- `JournalStore` owns the `JournalCache` and exposes `Flow<List<JournalPreview>>`.
- `InspirationStore` owns the `InspirationCache` and handles token refresh on 401.

### Presentation Layer

Shared ViewModels are simple coordinators:
- They call Store methods.
- They map Store flows into feature-specific UI state.
- They handle UI concerns like loading flags, errors, pagination, and autosave.

`KmpViewModel` provides a coroutine scope and a `clear()` method for lifecycle cleanup.

## Storage and Caching

There are two storage categories.

### Secure Tokens

- Android: `AndroidSecureTokenStorage` uses `EncryptedSharedPreferences`.
- iOS: `IosTokenStorage` uses `NSUserDefaults` (not Keychain).

`TokenStorage.observeHasTokens()` emits authentication state changes which drive UI routing.

### In-Memory Caches

- `InMemoryJournalCache` keeps a list of previews and a map of full entries.
- `InMemoryInspirationCache` keeps the latest quote.

These caches are not persisted to disk. They reset when the process restarts.

## Cross-Platform Configuration

### Base URL Selection

- Build-time flag `USE_PRODUCTION` is generated by Gradle in `JanusLeafBuildConfig`.
- `ApiConfig` selects a platform-specific base URL in development mode.
  - Android emulator uses `http://10.0.2.2:8080`.
  - iOS simulator uses `http://localhost:8080`.
- Production mode uses `ServerAvailabilityManager` for failover.
  - Performs health checks and caches a working server for 5 minutes.

### HTTP Client

- Common configuration lives in `HttpClientFactory.kt`.
- Android uses OkHttp engine.
- iOS uses Darwin engine.

## Android Wiring (Compose)

Android uses Koin for dependency injection.

- Modules:
  - `commonModule` from shared (networking + repositories).
  - `platformModule` from shared (Android token storage).
  - `uiModule` from composeApp (stores + view models).
- `JanusLeafApplication` starts Koin and configures logging.
- `rememberKmpViewModel()` creates shared ViewModels and calls `clear()` on dispose.
- `MainActivity` observes auth state and clears caches on logout.

## iOS Wiring (SwiftUI) — Read Carefully

iOS does not use Koin. Instead, it uses a Kotlin singleton that builds its own graph.

### `SharedModule` (Kotlin) acts as the DI container

`SharedModule` lives in `shared/src/iosMain` and manually creates:
- `IosTokenStorage`
- Ktor `HttpClient`
- API services
- Repository implementations
- Stores (AuthStore, JournalStore, InspirationStore)
- ViewModels

This is why iOS does not call Koin. It calls `SharedModule.shared.createXViewModel()`.

### `FlowObserver` bridges Kotlin Flow to Swift

`FlowObserver` collects Kotlin `Flow` on the main dispatcher and invokes a Swift callback.
It returns a `Cancellable` that must be cancelled to stop collection.

### Swift Adapters

Each shared ViewModel has a Swift adapter that:
- Owns the shared ViewModel.
- Subscribes to Kotlin flows with `FlowObserver`.
- Exposes `@Published` properties for SwiftUI.
- Cancels flow subscriptions and calls `viewModel.clear()` in `deinit`.

Current adapters:
- `AuthViewModelAdapter`
- `JournalListViewModelAdapter`
- `JournalEditorViewModelAdapter`
- `MoodInsightsViewModelAdapter`

### Type Conversion Patterns

Kotlin/Native types do not always map 1:1 to Swift types. The adapters handle this:
- `KotlinBoolean` -> `Bool` using `.boolValue`.
- `KotlinArray` -> Swift arrays using helper conversion.
- Kotlin `LocalDate` is created via `SharedModule.shared.parseLocalDate(iso:)`.
- Kotlin `Instant` is converted using `epochSeconds` to create Swift `Date`.

### SwiftUI Ownership and Lifecycle

Key rules to avoid leaks and unexpected updates:
- Use `@StateObject` for adapters you want to keep alive for a screen’s lifetime.
- Use `@EnvironmentObject` for global state like authentication.
- Always let adapters deinit so they can cancel Flow observers and clear coroutines.
- Avoid creating adapters inside view bodies without `@StateObject`.

## Platform Differences That Affect Behavior

- Android clears `JournalStore` and `InspirationStore` caches on logout.
  - This happens in `MainActivity` when auth state changes.
- iOS currently does not clear caches on logout.
  - If you need parity, expose a cache-clearing method or add a Swift helper.
- iOS token storage uses `NSUserDefaults`, which is not encrypted.
  - If security requirements demand Keychain, replace `IosTokenStorage`.

## Adding a New Feature (Checklist)

1. Add domain models and result types in `shared/domain/model`.
2. Add DTOs and API service methods in `shared/data/remote`.
3. Extend repository interfaces in `shared/domain/repository`.
4. Implement repository methods in `shared/data/repository`.
5. Add or extend a Store in `shared/model/store`.
6. Create a shared ViewModel in `shared/presentation/viewmodel`.
7. Android: register the ViewModel in `composeApp/di/UiModule.kt`.
8. iOS: create a Swift adapter and bind it to SwiftUI views.

This keeps Android and iOS behavior consistent while sharing the logic in Kotlin.
